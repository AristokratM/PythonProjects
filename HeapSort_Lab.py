def sink(lst, i, n):
    k = i
    j = 2 * k + 1  # Знаходимо позицію в масиві лівої дитини
    placed = False
    while not placed and j < n:
        if j < n - 1 and lst[j] < lst[j + 1]:  # Знаходимо максимальний елемент серед дітей
            j += 1
        if lst[k] >= lst[j]:  # Перевіряємо чи значення у батьківській вершині
            placed = True     # більше чим максимальне значення серед дітей
        else:
            lst[k], lst[j] = lst[j], lst[k]  # Якщо ні, то робимо swap між цими вершинами
        k = j  # Спускаємося глибше у дерево
        j = 2 * k + 1


def heap_sort(lst):
    n = len(lst)  # Вираховуємо довжину масиву
    for i in range((n - 1) // 2, -1, -1):  # Побудова максимальної купи
        sink(lst, i, n)
    print("Максимальна купа із початкової послідовності", lst)
    while n > 0:
        lst[0], lst[n - 1] = lst[n - 1], lst[0]  # Swap першого і останнього елементу максимальної купи
        n -= 1  # Зменьшуємо розмір купи
        sink(lst, 0, n)  # Просіювання
        print("Максимальна купа розміру {}".format(n), lst[:n])


lst = [61, 32, 27, 45, 75, 58, 5, 50, 99]
print("Початкова послідовність", lst)
heap_sort(lst)
print("Відсортована послідовність", lst)